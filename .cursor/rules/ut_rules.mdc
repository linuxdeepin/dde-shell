# Qt/C++ 单元测试规范

本规范定义了Qt/C++项目中单元测试的组织结构、编写标准和最佳实践。

## 项目结构规范

### 目录组织
- 源代码放置在 `src/` 目录
- 测试代码放置在 `tests/` 目录，结构与源代码目录对应
- 第三方库放置在 `3rdparty/` 目录，包含cpp-stub等mock工具
- 测试文件命名格式：`ut_classname.cpp`

### CMake配置要求
- 主项目CMakeLists.txt需要启用testing并添加tests子目录
- 测试项目需要链接GTest库和必要的编译参数
- 必须包含代码覆盖率支持的编译选项：`-fprofile-arcs -ftest-coverage -lgcov`
- 添加打桩支持的编译参数：`-fno-access-control -fno-inline -Wno-pmf-conversions`

## 测试编写原则

### AIR原则（必须遵守）
- **Automatic（自动化）**：测试必须全自动执行，无需人工干预
- **Independent（独立性）**：测试用例之间不能有依赖关系或执行顺序要求
- **Repeatable（可重复）**：测试结果不受外部环境影响，可重复执行

### 测试用例质量要求
- 每个测试用例必须有明确的检查点（断言）
- 测试用例命名采用格式：`[MethodUnderTest]_[Scenario]_[ExpectedResult]`
- 优先使用`EXPECT_*`系列断言而非`ASSERT_*`，避免内存泄漏风险
- 使用`TEST_F`宏组织相关测试，通过`SetUp()`和`TearDown()`管理资源

### 测试范围界定
- 单元测试针对单个类或函数的内部逻辑，不测试模块间交互
- 对外部依赖（文件系统、网络、硬件、数据库等）必须进行打桩隔离
- 避免测试中包含时间依赖、异步流程、全局变量等不稳定因素

## 打桩策略

### 工具选择
- 使用**cpp-stub**进行函数级别的打桩，适用于普通函数和成员函数
- 使用**gmock**进行接口级别的mock，适用于虚函数接口
- 结合**QTest**进行Qt特有功能测试（信号槽、GUI交互）

### 打桩原则
- 对所有外部依赖进行打桩，确保测试的独立性和可重复性
- 通过打桩控制不同的执行分支，实现完整的场景覆盖
- 在`SetUp()`中初始化打桩，在`TearDown()`中清理资源

## 代码质量保证

### 覆盖率要求
- 使用lcov工具生成代码覆盖率报告
- 关注场景覆盖而非单纯的代码行覆盖率
- 排除测试代码和第三方库的覆盖率统计

### 性能考虑
- 测试执行速度要快，避免长时间运行的操作
- 合理使用并行测试执行
- 及时清理测试过程中创建的资源，防止内存泄漏

### 环境隔离
- 测试不能修改系统环境或删除系统资源
- 测试创建的临时文件和数据必须在测试结束后清理
- 避免测试对生产环境造成任何影响

## Qt特定测试指导

### 信号槽测试
- 使用QSignalSpy监控信号发射
- 通过打桩验证信号槽的调用关系
- 测试信号参数的正确性

### GUI测试集成
- 结合QTest进行键盘鼠标事件模拟
- 使用GTest的断言进行结果验证
- 避免依赖真实的用户界面环境

## 常见问题避免

### 测试稳定性
- 不要在测试中使用随机数或当前时间
- 避免依赖网络连接或外部服务
- 不要在测试中使用sleep或延时操作

### 测试独立性
- 每个测试用例都应该能够单独运行
- 测试用例之间不能共享状态或数据
- 避免使用全局变量或静态变量传递测试数据

### 资源管理
- 在SetUp()中创建的资源必须在TearDown()中释放
- 使用RAII原则管理动态分配的内存
- 确保异常情况下资源也能正确释放

通过遵循这些规范，可以构建高质量、可维护的Qt/C++单元测试套件，有效保障代码质量和系统稳定性。
